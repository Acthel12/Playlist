BIT츼CORA DE LA ELABORACI칍N DEL PROGRAMA DE REPRODUCCI칍N DE PLAYLIST

ALUMNOS: 
JUAN VILLARROEL. C.I: 32051184.
GABRIEL CARNEIRO. C.I: 32051221.
UNIDAD CURRICULAR: ESTRUCTURA DE DATOS V-01.


D칤a 1 (21/02/2026)
1.Se cre칩 el proyecto.
2.Se programaron las estructuras de datos (nodo,java) siguiendo lo visto en clase.

D칤a 2 (22/02/2026)
1.Se cre칩 la clase de pila para las diferentes funciones del historial.
2.Se cre칩 la clase Lista.java para manejar la playlist y sus reproducciones.
3.Se desarrollaron los m칠todos de inserci칩n AgregarCancionComienzo y AgregarCancionFinal para manejar el flujo de la playlist.
4.Se nos dificult칩 un poco la l칩gica de desapilar en la clase pila, ya que hab칤a que asegurar que al sacar un elemento, la cabeza de la pila se moviera al siguiente nodo correctamente para no perder la referencia del historial restante. Pero lo entendimos al final luego de ensayo-error.
5.Se le consult칩 a gemini si la l칩gica de la clase pila era funcional y esta fue su respuesta:

춰Funciona perfectamente! Has logrado implementar correctamente el comportamiento LIFO (Last-In, First-Out) de una pila. Tu l칩gica para manejar los casos de una pila vac칤a, una pila con un solo elemento y una pila con m칰ltiples elementos en el m칠todo Desapilar es impecable y no tiene errores l칩gicos. 游녪

Se utiliz칩 el siguiente prompt: Revisa este c칩digo de java sobre una pila y dime si cumple con el m칠todo LIFO:

public class Pila {

public class Pila {
        Nodo cabeza;
        
        public Pila (){
            this.cabeza = null;
        }
        
        public void Apilar(Nodo cancion){
            if (this.cabeza == null){
                this.cabeza = cancion;
            }
            else {
                cancion.siguiente = this.cabeza;
                this.cabeza = cancion;
            }
        }
        public Nodo Desapilar(){
            if (this.cabeza == null){
                System.out.println("Error: el historial esta vac칤o");
                return null;
            }
            else {
                Nodo actual = this.cabeza;
                this.cabeza = this.cabeza.siguiente;
                actual.siguiente = null;
                
                return actual;
            }
        }
        public void MostrarHistorial(){
            if (this.cabeza != null){
                System.out.println("Historial de canciones");
                int contador = 0;
                Nodo siguiente = this.cabeza;
                while ( siguiente != null){
                    contador += 1;
                    System.out.println(contador + ". " + siguiente.cancion);
                    siguiente = siguiente.siguiente;
                }
            }
            else {
                System.out.println("El historial esta vac칤o");
            }
        }
}

D칤a 3 (23/02/2026)
1.Se cre칩 la clase principal playlist.java.
2.Se estructur칩 el men칰 principal con un ciclo while y un switch para las 7 opciones del usuario.
3.Se estructur칩 la l칩gica para leer con un esc치ner el input del usuario para elegir la opci칩n deseada.
4..Se conect칩 la l칩gica de reproducci칩n para la opci칩n 3. Al reproducir, la canci칩n actual se mueve de la lista al historial en la pila.
5.Se implement칩 la opci칩n 4 de ReproducirAnterior, que recupera el nodo del historial y lo vuelve a insertar al inicio de la playlist usando AgregarCancionComienzo.
6.Se implementaron las opciones 2, 5 y 6 conect치ndolas con las funciones ya elaboradas de las otras clases.
7.Buscamos ayuda de gemini para saber cu치l era el equivalente del match-case en python pero en java, ya que no lo record치bamos.

El prompt usado fue el siguiente: Como puedo realizar un match case de python pero en java?

Su respuesta fue:

S칤, es totalmente posible. A partir de Java 21 (versi칩n LTS), la funcionalidad equivalente al match-case de Python se llama Pattern Matching for Switch (Patr칩n de coincidencia para Switch).

Aunque Java utiliza la palabra clave cl치sica switch, ha sido supervitaminada para comportarse casi igual que en Python.

Aqu칤 tienes c칩mo hacerlo, comparando ambos lenguajes.

1. La Sintaxis Moderna (Java 21+)
En Python har칤as esto para verificar tipos y condiciones:

Python

# Python
def procesar(dato):
    match dato:
        case int(i) if i > 0:
            print(f"Entero positivo: {i}")
        case str(s):
            print(f"Es un texto: {s}")
        case None:
            print("Es nulo")
        case _:
            print("Otra cosa")
En Java, usas switch con la sintaxis de flecha (->) y la palabra clave when para las condiciones (guardas):

Java

// Java 21+
void procesar(Object dato) {
    switch (dato) {
        // Coincidencia de tipo + Condici칩n (Guard)
        case Integer i when i > 0 -> 
            System.out.println("Entero positivo: " + i);
            
        // Coincidencia de tipo simple
        case String s -> 
            System.out.println("Es un texto: " + s);
            
        // Manejo de nulos (antes el switch lanzaba error con null)
        case null -> 
            System.out.println("Es nulo");
            
        // Caso por defecto (equivalente a case _ en Python)
        default -> 
            System.out.println("Otra cosa");
    }
}

Nota: que risa las descripciones de gemini; "supervitaminada".

D칤a 4 (24/02/2026)
1.Se implement칩 el manejo de errores con try-catch en el main para evitar que el programa colapse si el usuario ingresa letras en lugar de n칰meros o si sucede alg칰n otro error. Para esto se le consult칩 a gemini como captar errores en java, para asegurarnos e usar la sintaxis y l칩gica correcta y verificar si era similar a C# (que es lo m치s similar a java que estamos viendo actualmente).

Los prompts usados fueron los siguientes:

(primer prompt) c칩mo capto un error en java cuando intento convertir una cadena de texto (string) en un n칰mero, pero el formato de la cadena no es v치lido para la conversi칩n.

La respuesta de gemini fue:
Para capturar este error en Java, necesitas familiarizarte con una excepci칩n espec칤fica: NumberFormatException. Esta ocurre cuando intentas transformar un String en un tipo num칠rico (como Integer o Double) y el contenido no es compatible.

El Bloque Try-Catch
La forma est치ndar de gestionar esto es envolver el c칩digo de conversi칩n en un bloque try-catch. Si la conversi칩n falla, el flujo del programa no se detiene abruptamente, sino que salta al bloque catch.

Java

public class EjemploConversion {
    public static void main(String[] args) {
        String textoInvalido = "123a"; // Esto causar치 un error

        try {
            // Intentamos la conversi칩n
            int numero = Integer.parseInt(textoInvalido);
            System.out.println("El n칰mero es: " + numero);
            
        } catch (NumberFormatException e) {
            // Aqu칤 manejamos el error
            System.err.println("Error: El texto '" + textoInvalido + "' no es un n칰mero v치lido.");
        }
    }
}

(segundo prompt) y si sucede alg칰n otro error en general c칩mo lo capto y lo muestro en la terminal?

La respuesta de gemini fue:

Para capturar cualquier otro tipo de error en Java, debemos escalar en la jerarqu칤a de clases de excepciones. En Java, la clase Exception es la madre de casi todos los errores que puedes manejar en tu c칩digo.

Aqu칤 te explico c칩mo capturarlos de forma general y c칩mo extraer la informaci칩n 칰til para mostrarla en la terminal.

1. El Capturador Universal (Exception)
Si quieres un "atrapalotodo", puedes usar la clase gen칠rica Exception. Es 칰til colocarla al final de tus bloques catch para asegurar que el programa no se detenga si ocurre algo inesperado (como un error de memoria, un archivo que no existe, o un valor nulo).

Java

try {
    // C칩digo que puede fallar (ej. divisi칩n por cero, acceso a 칤ndice inexistente)
    int resultado = 10 / 0; 
} catch (NumberFormatException e) {
    System.err.println("Error espec칤fico: No es un n칰mero.");
} catch (Exception e) {
    // Captura CUALQUIER otra cosa que no sea NumberFormatException
    System.err.println("Ocurri칩 un error inesperado: " + e.getMessage());
}
2. C칩mo mostrar el error detallado
Cuando capturas una excepci칩n, el objeto e contiene informaci칩n valiosa. Tienes tres formas principales de mostrarla en la terminal:

A. El mensaje corto (getMessage())
Ideal para el usuario final o logs limpios. Solo te dice qu칠 sali칩 mal.

Java

System.out.println("Error: " + e.getMessage());


2.Se a침adi칩 el m칠todo est치tico limpiarPantalla() imprimiendo l칤neas vac칤as para mejorar la est칠tica en la consola. Esto tambi칠n se le consult칩 a gemini ya que no sab칤amos como manejar esto en java, nunca lo hab칤amos hecho. Al hacerlo, nos enteramos que NetBeans no posee una terminal como tal y por ende no funciona el limpiar la pantalla, as칤 que gemini nos dio otra opci칩n que es agregar saltos de l칤neas para que lo anterior desaparezca de la vista del usuario; esto no se ve de lo mejor, pero funciona para que la gente no se confunda y se vea m치s est칠tico.

El prompt utilizado fue:
necesito una ayuda para un proyecto de programaci칩n en java, de qu칠 forma puedo limpiar la terminal si tengo un men칰 para mi programa manejado en la terminal?

Su respuesta fue esta:

Limpiar la consola en Java es un problema cl치sico porque Java est치 dise침ado para ser multiplataforma y la "consola" depende del sistema operativo (Windows, Linux, macOS), no del lenguaje en s칤.

Aqu칤 te presento las tres formas m치s efectivas de hacerlo, ordenadas de la m치s recomendada a la soluci칩n "de emergencia".

1. El m칠todo moderno (C칩digos de escape ANSI)
Esta es la forma m치s limpia y r치pida. Funciona en casi todos los terminales modernos (Linux, macOS, y Windows 10/11 en PowerShell o CMD modernos).

Utiliza c칩digos especiales que el terminal interpreta como "borrar pantalla" y "mover cursor al inicio".

Java

public static void limpiarPantalla() {
    System.out.print("\033[H\033[2J");
    System.out.flush();
}
C칩mo funciona: \033 es el car치cter de escape. [H mueve el cursor arriba a la izquierda y [2J limpia la pantalla.

2. El m칠todo robusto (ProcessBuilder)
Si est치s en una versi칩n antigua de Windows o el m칠todo ANSI falla, puedes invocar directamente el comando del sistema operativo (cls en Windows, clear en Unix/Linux/Mac).

Java

public static void limpiarPantalla() {
    try {
        if (System.getProperty("os.name").contains("Windows")) {
            new ProcessBuilder("cmd", "/c", "cls").inheritIO().start().waitFor();
        } else {
            new ProcessBuilder("clear").inheritIO().start().waitFor();
        }
    } catch (Exception e) {
        // Si falla, imprimimos saltos de l칤nea como plan B
        System.out.println("Error al limpiar pantalla: " + e.getMessage());
    }
}
Nota: Este m칠todo puede ser ligeramente m치s lento porque crea un nuevo proceso en el sistema.

3. El m칠todo "sucio" (Saltos de l칤nea)
Si nada de lo anterior funciona (o si el profesor te pide una soluci칩n muy b치sica), simplemente imprime muchas l칤neas vac칤as para "empujar" el texto viejo hacia arriba.

Java

public static void limpiarPantalla() {
    for (int i = 0; i < 50; i++) {
        System.out.println();
    }
}
丘멆잺 Importante: El problema de los IDEs
Es muy probable que si ejecutas esto dentro de NetBeans, Eclipse o IntelliJ (en la ventana de "Output" o "Run"), NO funcione.

쯇or qu칠? Porque la ventana de salida de los IDEs no es una verdadera terminal; es solo un visor de texto. No interpreta comandos de limpieza.

La soluci칩n: Para probar que tu men칰 funciona, debes compilar tu programa y ejecutarlo desde la terminal real de tu computadora (CMD, PowerShell o Terminal).

Nota: Menos mal nos dijo que no serv칤a en netbeans, porque lo probamos y en efecto no funcion칩 :(. As칤 que le preguntamos de nuevo:

Prompt utilizado: estoy utilizando netbeans, no hay manera de limpiar la terminal de netbeans entre interacciones de las opciones del men칰?

Su respuesta fue:

Esa es una de las limitaciones m치s frustrantes de NetBeans (y de la mayor칤a de los IDEs como Eclipse o IntelliJ).

La respuesta corta es: No, no existe un comando de c칩digo que pueda borrar la ventana de "Output" nativa de NetBeans, porque esa ventana no es una terminal real, es solo un registro de texto (log). No acepta comandos del sistema ni c칩digos de limpieza.

Sin embargo, tienes dos soluciones para lograr el efecto que buscas:

Soluci칩n 1: El "Truco Visual" (Funciona dentro de NetBeans)
Como la ventana de Output no se puede borrar, lo 칰nico que puedes hacer es "empujar" el texto hacia arriba para simular una limpieza.

Crea este m칠todo y ll치malo cuando necesites limpiar:

Java

public static void limpiarAnt() {
    // Imprime 50 l칤neas vac칤as
    for (int i = 0; i < 50; i++) {
        System.out.println();
    }
}
Resultado: El usuario ver치 la pantalla "limpia" porque el men칰 anterior subi칩 y desapareci칩 de la vista inmediata, aunque si hace scroll hacia arriba, ver치 el historial.

Soluci칩n 2: Configurar NetBeans para usar la Terminal Externa (La mejor opci칩n)
Esta es la soluci칩n profesional. En lugar de ejecutar tu programa en la ventanita de abajo de NetBeans, puedes configurarlo para que se abra en una ventana real de CMD o PowerShell (o Terminal en Mac/Linux).

Al hacer esto, los c칩digos de limpieza reales (cls, clear) s칤 funcionar치n.

Pasos para configurarlo en NetBeans:

Haz clic derecho sobre el nombre de tu proyecto (el 칤cono de la taza de caf칠) en el panel izquierdo "Projects".

Selecciona Properties (Propiedades) al final del men칰.

En la lista de la izquierda, busca la categor칤a Run (Ejecutar).

Busca la opci칩n que dice Console Type (Tipo de Consola).

Por defecto dice Internal Output.

C치mbialo a External Terminal (o External Console).

Dale a OK y ejecuta tu programa de nuevo (Run).

Ahora, tu programa se abrir치 en una ventana negra separada. Ah칤 s칤 funcionar치 el c칩digo robusto que te di antes:

Java

public static void limpiarPantalla() {
    try {
        if (System.getProperty("os.name").contains("Windows")) {
            new ProcessBuilder("cmd", "/c", "cls").inheritIO().start().waitFor();
        } else {
            new ProcessBuilder("clear").inheritIO().start().waitFor();
        }
    } catch (Exception e) {
        System.out.println("Error al limpiar");
    }
}

Resumen
Si quieres quedarte dentro de la ventanita de NetBeans: Usa el bucle de 50 saltos de l칤nea.

Si quieres que funcione limpiando de verdad: Cambia la configuraci칩n a "External Terminal".

Nota: En efecto no quer칤amos configurar netbeans para utilizar una terminal externa, la idea era que el programa funcionara de la forma m치s nativa posible. As칤 que nos decidimos por los saltos de l칤nea, espero que no le sea muy molesto verlo as칤 profe :(.

3.Se pulieron los mensajes de salida para que el usuario sepa qu칠 canci칩n se est치 reproduciendo o si la lista est치 vac칤a. Solo detalles visuales.


MENCI칍N HONOR칈FICA DE INCONVENIENTES AL INICIO DE ELABORACI칍N DEL PROGRAMA:

El push al repositorio de github a trav칠s de netbeans no funcionaba, ped칤a una clave y coloc치bamos nuestra clave de github y no funcionaba. As칤 que por supuesto recurrimos a gemini para solucionarlo lo m치s r치pido posible y gracias a Dios que ella siempre ayuda paso a paso cuando tienes inconvenientes.

El prompt fue: netbeans no me deja hacer push a un repositorio de github, me pide una clave, que hago?

Su respuesta fue:

Ese error es muy com칰n. Desde hace un tiempo, GitHub ya no permite usar tu contrase침a normal para operaciones de Git (como el push) por razones de seguridad. Ahora necesitas un Personal Access Token (PAT) o configurar una clave SSH.

Lo m치s r치pido para solucionar esto en NetBeans es generar un Token de Acceso Personal. Aqu칤 tienes los pasos:

1. Generar el Token en GitHub
Entra a tu cuenta de GitHub en el navegador.

Ve a Settings (Configuraci칩n) > Developer settings (al final de la columna izquierda).

Selecciona Personal access tokens > Tokens (classic).

Haz clic en Generate new token (classic).

Ponle un nombre (ej. "NetBeans") y selecciona la duraci칩n (puedes poner 90 d칤as o sin expiraci칩n).

Importante: Marca la casilla que dice repo (esto permite hacer push a tus repositorios).

Haz clic en Generate token.

Copia el token y gu치rdalo en un lugar seguro. No podr치s volver a verlo una vez que cierres la p치gina.

2. Usar el Token en NetBeans
Cuando NetBeans te pida la clave para hacer el push:

Username: Tu nombre de usuario de GitHub.

Password: Pega el Token que acabas de generar (no tu contrase침a de siempre).

Tip: Aseg칰rate de marcar la casilla "Remember Password" en la ventana de NetBeans para que no tengas que pegarlo cada vez que quieras subir cambios.

Nota: Luego de eso seguimos sus pasos y generamos el token en la p치gina de GitHub. Fue algo s칰per loco para nosotros porque ya ven칤amos acostumbrados a que en Visual Studio y Visual Studio Code no se hace eso.


Eso es todo profe, espero que le guste nuestro programa, aprendimos bastante haci칠ndolo :)